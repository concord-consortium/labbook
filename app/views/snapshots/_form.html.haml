= javascript_include_tag SHUTTERBUG_JS
.snapshot-form
  = form_for([@album, @snapshot], html: { id: "snapshot_form_#{@snapshot.id}"}) do |f|
    .left
      - if @snapshot.persisted?
        .persisted_image{:id => "persisted_image_#{@snapshot.id}"}
        = f.hidden_field :annotation, id: "snapshot_annotation_#{@snapshot.id}"
        = f.hidden_field :annotated_snapshot_url, id: "annotated_snapshot_url_#{@snapshot.id}"

      - unless @snapshot.content.present?
        %div
          %span#file-upload-button.fileinput-button
            %span Browse...
            / The file input field used as target for the file upload widget/
            %input#fileupload{:name => "snapshot[content]", :type => "file"}
        #progress
          .bar
    .right
      - if @snapshot.persisted?
        .instructions
          Use the tools on the left to draw on your snapshot. Write your comments in the box below the snapshot and click Save when you are done.
      - if @snapshot.errors.any?
        #error_explanation
          %h2
            = pluralize(@snapshot.errors.count, "error")
            prohibited this snapshot from being saved:
          %ul
            - @snapshot.errors.full_messages.each do |msg|
              %li= msg
              %div
      %h3
        Comments:
      #comments-wrapper
        = f.text_area :comment
      .actions
        = f.submit "Save", class: 'button', id: "snapshot_submit_#{@snapshot.id}"
        = link_to 'Cancel', @album, class: "button"

  :javascript
      $(function () {
        var url = "#{@snapshot.persisted? ? album_snapshot_path(@album,@snapshot) : album_snapshots_path(@album)}";
        $('#fileupload').fileupload({
          url: url,
          dataType: 'json',
          add: function (e, data) {
            $('.fileinput-button').hide();
            $('.actions input').prop('disabled', true);
            $('#comments-wrapper .textarea').prop('disabled', true);
            data.submit();
          },
          done: function (e, data) {
            window.location = data.result.edit_path;
          },
          progressall: function (e, data) {
            var progress = parseInt(data.loaded / data.total * 100, 10);
            $('#progress .bar').css(
              'width',
              progress + '%'
            );
          },
          fileuploadfail: function(e, data) {
            console.log("Failed!", e, data);
            $('.actions input').prop('disabled', false);
            $('#comments-wrapper .textarea').prop('disabled', false);
          }
        });
      });
      $(document).ready(function() {
        var firstSubmit = true;
        var originalData = "";
        var drawingTool = new DrawingTool("#persisted_image_#{@snapshot.id}", {width: 500, height: 560});
        var drawToolStateHasChanged = function() {
          return originalData != drawingTool.canvas.toDataURL();
        };
        var phone = iframePhone.getIFrameEndpoint();

        // the drawing tool doesn't expose if the document is dirty but it does send events on undoable and redoable actions
        // the first attempt at this kept a counter of undo events (decrementing when 'redo:possible' was received) but since
        // the undo button itself sends a redo:possible event and there is no way to check if there are any other actions
        // on the undo/redo stack, that counter was removed.  A simple flag is now set when anything undoable happens - this isn't
        // ideal as if the user uses the undo button back to a "clean" document LARA will still think it is dirty
        var hasUnsavedState = function (value) {
          phone.post('interactiveState', value ? {hasUnsavedState: true} : 'nochange');
        };
        var listenForDrawingChanges = function() {
          drawingTool.on('undo:possible', function () {
            hasUnsavedState(true);
          })
        };
        phone.initialize();

        $('#snapshot_form_#{@snapshot.id}').submit(function() {
          if (firstSubmit && drawToolStateHasChanged()) {
            var state = JSON.stringify(drawingTool.save());
            $('#snapshot_annotation_#{@snapshot.id}').val(state);
            $(function() {
              var optCallbackFn = function(snap_location) {
                if (snap_location != null) {
                  if (snap_location.indexOf('://') == -1) {
                    snap_location = window.location.protocol + "//" + window.location.host + snap_location;
                  }
                  $("#annotated_snapshot_url_#{@snapshot.id}").val(snap_location);
                }

                firstSubmit = false;
                $('#snapshot_form_#{@snapshot.id}').submit();

                hasUnsavedState(false);
              };

              $('#snapshot_submit_#{@snapshot.id}').attr('disabled', 'disabled');
              $('#snapshot_submit_#{@snapshot.id}').val('Please wait...');

              drawingTool.clearSelection();

              Shutterbug.snapshot({ selector: "#persisted_image_#{@snapshot.id} .canvas-container", done: optCallbackFn, server: '#{SHUTTERBUG_SERVER}'});
            });
            return false;
          } else {
            return true;
          }
        });
        var prev_state = $('#snapshot_annotation_#{@snapshot.id}').val();
        if (prev_state) {
          drawingTool.load(JSON.parse(prev_state), function() { originalData = drawingTool.canvas.toDataURL(); listenForDrawingChanges() });
        } else {
          drawingTool.setBackgroundImage("#{@snapshot.content.url(:medium)}", undefined, listenForDrawingChanges);
          originalData = drawingTool.canvas.toDataURL();
        }

      });